<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>blog</title>
	</head>
	<style type="text/css">
		li{
			list-style: none;
		}
		html{
			background-image: url(./images/clouds_front.jpg);
			background-repeat:no-repeat;
			background-size: 100%;
		}
		#box{
			width: 1000px;
			
			margin: 0 auto;
		}
	</style>
	<body>	
	<div id="box">
		
		<h3>热更新问题</h3>
					<p>vite 采用立即编译当前修改文件的办法。同时 vite 还会使用缓存机制( http 缓存 => vite 内置缓存 )，加载更新后的文件内容
		
		所以，vite 具有了快速冷启动、按需编译、模块热更新等优良特质</p>
					<ul>
						<li>Vite 在开发模式下不需要打包可以直接运行，使用的是 ES6 的模块化加载规则；Vue-CLI 开发模式下必须对项目打包才可以运行</li>
						<li>Vite 基于缓存的热更新，Vue-CLI 基于 Webpack 的热更新</li>
					</ul>
				<h3>vite的启动链路</h3>
				<ul>
					<li>这部分代码在 src/node/cli.ts 里，主要内容是借助 minimist —— 一个轻量级的命令解析工具解析 npm scripts，解析的函数是 resolveOptions ，精简后的代码片段如下</li>
					
						<pre>
							function resolveOptions() {
							    // command 可以是 dev/build/optimize
							    if (argv._[0]) {
							        argv.command = argv._[0]
							    }
							    return argv
							}
						</pre>
					
					<li>拿到 options 后，会根据 options.command 的值判断是执行在开发环境需要的 runServe 命令或生产环境需要的 runBuild 命令</li>
					
						<pre>
							if (!options.command || options.command === 'serve') {
							    runServe(options)
							 } else if (options.command === 'build') {
							    runBuild(options)
							 } else if (options.command === 'optimize') {
							    runOptimize(options)
							 }
						</pre>
					
					<li>
						在 runServe 方法中，执行 server 模块的创建开发服务器方法，同样在 runBuild 中执行 build 模块的构建方法
					</li>
					
					
				</ul>
				
	</div>
			
			
	</body>
</html>